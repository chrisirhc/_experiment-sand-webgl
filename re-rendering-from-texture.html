<html>
  <head>
    <title>Drawing</title>
    <style>
      body { margin: 0; background: #ccc; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="lib/three.js"></script>
    <script id="vertexshader" type="x-shader/x-vertex">
    varying vec2 vUv;
    /**
     * Multiply each vertex by the model-view matrix
     * and the projection matrix (both provided by
     * Three.js) to get a final vertex position
     */
    void main() {
        vUv = uv;

        gl_Position = projectionMatrix *
                      modelViewMatrix *
                      vec4(position, 1.0);
    }
    </script>
    <script id="fragmentshader" type="x-shader/x-fragment">
    uniform sampler2D tex;
    varying vec2 vUv;
    /**
     * Set the colour to a lovely pink.
     * Note that the color is a 4D Float
     * Vector, R,G,B and A and each part
     * runs from 0.0 to 1.0
     */
    void main() {
      gl_FragColor = texture2D(tex, vec2(vUv.s, vUv.t)) + vec4(0.01);
    }
    </script>
    <script>
      var width = 1024;
      var height = 768;
      var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, -10, 1000 );

      var renderer = makeRenderer();
      var rtRenderers = [
        new THREE.WebGLRenderTarget( width, height, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat }),
        new THREE.WebGLRenderTarget( width, height, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat }),
      ];

      var scenes = [
        makeScene(rtRenderers[1]),
        makeScene(rtRenderers[0]),
      ];

      makeCanvasTexture(renderer, rtRenderers[1], function () {
        document.body.appendChild( renderer.domElement );
        render();
      });

      var nextRenderIdx = 0;
      function render() {
        requestAnimationFrame( render );

        // Render to texture first
        renderer.render( scenes[nextRenderIdx], camera, rtRenderers[nextRenderIdx], true );

        // Render texture
        renderer.render( scenes[1 - nextRenderIdx], camera);

        // Swap render target (text)
        nextRenderIdx = (nextRenderIdx + 1) % rtRenderers.length;
      }

      function makeRenderer() {
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize( width, height );
        return renderer;
      }

      function makeScene(renderFromTexture) {
        var scene = new THREE.Scene();

        var geometry = new THREE.BoxGeometry( width, height, 1 );

        var uniforms = {
          tex: {
            type: 't',
            value: renderFromTexture,
          },
        };

        var shaderMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader:   document.querySelector('#vertexshader').textContent,
            fragmentShader: document.querySelector('#fragmentshader').textContent
        });
        var plane = new THREE.Mesh( geometry, shaderMaterial );
        scene.add( plane );

        return scene;
      }

      function makeCanvasTexture(renderer, rtRenderer, done) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        var texture = new THREE.Texture(canvas);

        var img = new Image();
        img.src = 'start-map.png';
        img.onload = function () {
          context.drawImage(img, 0, 0);
          if (texture) {
            texture.needsUpdate = true;
          }

          renderer.render(scene, camera, rtRenderer, true);
          done();
        };

        var material = new THREE.MeshBasicMaterial({
          map: texture,
        });
        material.transparent = true;

        var mesh =  new THREE.Mesh(
          new THREE.PlaneGeometry(width, height),
          material);

        var scene = new THREE.Scene();
        scene.add( mesh );
      }

    </script>
  </body>
</html>